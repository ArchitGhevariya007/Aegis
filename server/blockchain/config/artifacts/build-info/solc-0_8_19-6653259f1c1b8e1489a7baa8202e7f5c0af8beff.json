{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_19-6653259f1c1b8e1489a7baa8202e7f5c0af8beff",
  "solcVersion": "0.8.19",
  "solcLongVersion": "0.8.19+commit.7dd6d404",
  "userSourceNameMap": {
    "contracts/DocumentManager.sol": "project/contracts/DocumentManager.sol",
    "contracts/VotingContract.sol": "project/contracts/VotingContract.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "paris",
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/DocumentManager.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.19;\r\n\r\n/**\r\n * @title DocumentManager\r\n * @dev Smart contract for managing encrypted documents on blockchain\r\n * @author Aegis Digital Identity System\r\n */\r\ncontract DocumentManager {\r\n    \r\n    struct Document {\r\n        string documentHash;      // SHA256 hash of original document\r\n        string ipfsHash;         // IPFS hash where encrypted document is stored\r\n        string encryptionKey;    // Encrypted key for document decryption\r\n        address owner;           // Document owner\r\n        uint256 timestamp;       // When document was stored\r\n        bool exists;            // Whether document exists\r\n    }\r\n    \r\n    struct AccessPermission {\r\n        bool canAccess;         // Whether user can access document\r\n        uint256 grantedAt;      // When access was granted\r\n        address grantedBy;      // Who granted the access\r\n    }\r\n    \r\n    // State variables\r\n    mapping(uint256 => Document) private documents;\r\n    mapping(address => uint256[]) private userDocuments;\r\n    mapping(uint256 => mapping(address => AccessPermission)) private documentPermissions;\r\n    \r\n    uint256 private nextDocumentId = 1;\r\n    address public owner;\r\n    \r\n    // Events\r\n    event DocumentStored(\r\n        uint256 indexed documentId,\r\n        address indexed owner,\r\n        string documentHash,\r\n        string ipfsHash,\r\n        uint256 timestamp\r\n    );\r\n    \r\n    event DocumentAccessed(\r\n        uint256 indexed documentId,\r\n        address indexed accessor,\r\n        uint256 timestamp\r\n    );\r\n    \r\n    event PermissionGranted(\r\n        uint256 indexed documentId,\r\n        address indexed owner,\r\n        address indexed grantee,\r\n        uint256 timestamp\r\n    );\r\n    \r\n    event PermissionRevoked(\r\n        uint256 indexed documentId,\r\n        address indexed owner,\r\n        address indexed grantee,\r\n        uint256 timestamp\r\n    );\r\n    \r\n    // Modifiers\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Only contract owner can call this function\");\r\n        _;\r\n    }\r\n    \r\n    modifier onlyDocumentOwner(uint256 _documentId) {\r\n        require(documents[_documentId].exists, \"Document does not exist\");\r\n        require(documents[_documentId].owner == msg.sender, \"Only document owner can call this function\");\r\n        _;\r\n    }\r\n    \r\n    modifier documentExists(uint256 _documentId) {\r\n        require(documents[_documentId].exists, \"Document does not exist\");\r\n        _;\r\n    }\r\n    \r\n    modifier hasDocumentAccess(uint256 _documentId) {\r\n        require(documents[_documentId].exists, \"Document does not exist\");\r\n        require(\r\n            documents[_documentId].owner == msg.sender || \r\n            documentPermissions[_documentId][msg.sender].canAccess,\r\n            \"Access denied\"\r\n        );\r\n        _;\r\n    }\r\n    \r\n    constructor() {\r\n        owner = msg.sender;\r\n    }\r\n    \r\n    /**\r\n     * @dev Store a new document on the blockchain\r\n     * @param _documentHash SHA256 hash of the original document\r\n     * @param _ipfsHash IPFS hash where encrypted document is stored\r\n     * @param _encryptionKey Encryption key for document decryption\r\n     * @param _documentOwner Owner of the document\r\n     * @return documentId The ID of the stored document\r\n     */\r\n    function storeDocument(\r\n        string memory _documentHash,\r\n        string memory _ipfsHash,\r\n        string memory _encryptionKey,\r\n        address _documentOwner\r\n    ) public returns (uint256) {\r\n        require(bytes(_documentHash).length > 0, \"Document hash cannot be empty\");\r\n        require(bytes(_ipfsHash).length > 0, \"IPFS hash cannot be empty\");\r\n        require(bytes(_encryptionKey).length > 0, \"Encryption key cannot be empty\");\r\n        require(_documentOwner != address(0), \"Invalid document owner address\");\r\n        \r\n        uint256 documentId = nextDocumentId;\r\n        nextDocumentId++;\r\n        \r\n        documents[documentId] = Document({\r\n            documentHash: _documentHash,\r\n            ipfsHash: _ipfsHash,\r\n            encryptionKey: _encryptionKey,\r\n            owner: _documentOwner,\r\n            timestamp: block.timestamp,\r\n            exists: true\r\n        });\r\n        \r\n        userDocuments[_documentOwner].push(documentId);\r\n        \r\n        emit DocumentStored(\r\n            documentId,\r\n            _documentOwner,\r\n            _documentHash,\r\n            _ipfsHash,\r\n            block.timestamp\r\n        );\r\n        \r\n        return documentId;\r\n    }\r\n    \r\n    /**\r\n     * @dev Get document information\r\n     * @param _documentId ID of the document\r\n     * @return documentHash SHA256 hash of the document\r\n     * @return ipfsHash IPFS hash of the encrypted document\r\n     * @return encryptionKey Encryption key for decryption\r\n     * @return documentOwner Owner of the document\r\n     * @return timestamp When the document was stored\r\n     */\r\n    function getDocument(uint256 _documentId) \r\n        public \r\n        view \r\n        hasDocumentAccess(_documentId) \r\n        returns (\r\n            string memory documentHash,\r\n            string memory ipfsHash,\r\n            string memory encryptionKey,\r\n            address documentOwner,\r\n            uint256 timestamp\r\n        ) \r\n    {\r\n        Document memory doc = documents[_documentId];\r\n        return (\r\n            doc.documentHash,\r\n            doc.ipfsHash,\r\n            doc.encryptionKey,\r\n            doc.owner,\r\n            doc.timestamp\r\n        );\r\n    }\r\n    \r\n    /**\r\n     * @dev Get all document IDs owned by a user\r\n     * @param _owner Address of the document owner\r\n     * @return Array of document IDs\r\n     */\r\n    function getUserDocuments(address _owner) public view returns (uint256[] memory) {\r\n        return userDocuments[_owner];\r\n    }\r\n    \r\n    /**\r\n     * @dev Grant access permission to a user for a specific document\r\n     * @param _documentId ID of the document\r\n     * @param _user Address of the user to grant access\r\n     * @param _canAccess Whether to grant or revoke access\r\n     */\r\n    function setDocumentPermission(\r\n        uint256 _documentId,\r\n        address _user,\r\n        bool _canAccess\r\n    ) public onlyDocumentOwner(_documentId) {\r\n        require(_user != address(0), \"Invalid user address\");\r\n        require(_user != documents[_documentId].owner, \"Cannot set permission for document owner\");\r\n        \r\n        documentPermissions[_documentId][_user] = AccessPermission({\r\n            canAccess: _canAccess,\r\n            grantedAt: block.timestamp,\r\n            grantedBy: msg.sender\r\n        });\r\n        \r\n        if (_canAccess) {\r\n            emit PermissionGranted(_documentId, msg.sender, _user, block.timestamp);\r\n        } else {\r\n            emit PermissionRevoked(_documentId, msg.sender, _user, block.timestamp);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev Check if a user has access to a document\r\n     * @param _documentId ID of the document\r\n     * @param _user Address of the user\r\n     * @return Whether the user has access\r\n     */\r\n    function hasAccess(uint256 _documentId, address _user) \r\n        public \r\n        view \r\n        documentExists(_documentId) \r\n        returns (bool) \r\n    {\r\n        return documents[_documentId].owner == _user || \r\n               documentPermissions[_documentId][_user].canAccess;\r\n    }\r\n    \r\n    /**\r\n     * @dev Get access permission details\r\n     * @param _documentId ID of the document\r\n     * @param _user Address of the user\r\n     * @return canAccess Whether user can access\r\n     * @return grantedAt When access was granted\r\n     * @return grantedBy Who granted the access\r\n     */\r\n    function getAccessPermission(uint256 _documentId, address _user) \r\n        public \r\n        view \r\n        documentExists(_documentId) \r\n        returns (bool canAccess, uint256 grantedAt, address grantedBy) \r\n    {\r\n        AccessPermission memory permission = documentPermissions[_documentId][_user];\r\n        return (permission.canAccess, permission.grantedAt, permission.grantedBy);\r\n    }\r\n    \r\n    /**\r\n     * @dev Record document access for audit trail\r\n     * @param _documentId ID of the document being accessed\r\n     */\r\n    function recordAccess(uint256 _documentId) public hasDocumentAccess(_documentId) {\r\n        emit DocumentAccessed(_documentId, msg.sender, block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * @dev Verify document integrity by comparing hashes\r\n     * @param _documentId ID of the document\r\n     * @param _providedHash Hash to verify against\r\n     * @return Whether the hashes match\r\n     */\r\n    function verifyDocumentIntegrity(uint256 _documentId, string memory _providedHash) \r\n        public \r\n        view \r\n        hasDocumentAccess(_documentId) \r\n        returns (bool) \r\n    {\r\n        return keccak256(abi.encodePacked(documents[_documentId].documentHash)) == \r\n               keccak256(abi.encodePacked(_providedHash));\r\n    }\r\n    \r\n    /**\r\n     * @dev Get total number of documents stored\r\n     * @return Total document count\r\n     */\r\n    function getTotalDocuments() public view returns (uint256) {\r\n        return nextDocumentId - 1;\r\n    }\r\n    \r\n    /**\r\n     * @dev Check if a document exists\r\n     * @param _documentId ID of the document\r\n     * @return Whether the document exists\r\n     */\r\n    function isDocumentExists(uint256 _documentId) public view returns (bool) {\r\n        return documents[_documentId].exists;\r\n    }\r\n    \r\n    /**\r\n     * @dev Get document owner\r\n     * @param _documentId ID of the document\r\n     * @return Address of the document owner\r\n     */\r\n    function getDocumentOwner(uint256 _documentId) \r\n        public \r\n        view \r\n        documentExists(_documentId) \r\n        returns (address) \r\n    {\r\n        return documents[_documentId].owner;\r\n    }\r\n    \r\n    /**\r\n     * @dev Emergency function to update contract owner (only current owner)\r\n     * @param _newOwner Address of the new contract owner\r\n     */\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        require(_newOwner != address(0), \"Invalid new owner address\");\r\n        owner = _newOwner;\r\n    }\r\n    \r\n    /**\r\n     * @dev Get contract version\r\n     * @return Contract version string\r\n     */\r\n    function getVersion() public pure returns (string memory) {\r\n        return \"1.0.0\";\r\n    }\r\n}\r\n"
      },
      "project/contracts/VotingContract.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.19;\r\n\r\n/**\r\n * @title SecureVotingContract\r\n * @dev Decentralized voting system with face verification and admin controls\r\n * @notice All votes are stored immutably on blockchain\r\n */\r\ncontract SecureVotingContract {\r\n    \r\n    // ============== State Variables ==============\r\n    \r\n    address public admin;\r\n    bool public isActive;\r\n    uint256 public sessionStartTime;\r\n    uint256 public sessionEndTime;\r\n    uint256 public totalVotes;\r\n    \r\n    // Party structure\r\n    struct Party {\r\n        string id;\r\n        string name;\r\n        string logo;\r\n        string color;\r\n        uint256 voteCount;\r\n        bool exists;\r\n    }\r\n    \r\n    // Vote record structure\r\n    struct Vote {\r\n        address voter;\r\n        string partyId;\r\n        uint256 timestamp;\r\n        bool faceVerified;\r\n        bytes32 voteHash;\r\n        bool exists;\r\n    }\r\n    \r\n    // Mappings\r\n    mapping(string => Party) public parties;\r\n    mapping(address => Vote) public votes;\r\n    mapping(address => bool) public hasVoted;\r\n    \r\n    // Arrays for iteration\r\n    string[] public partyIds;\r\n    address[] public voters;\r\n    \r\n    // Events\r\n    event VotingStarted(uint256 timestamp);\r\n    event VotingStopped(uint256 timestamp);\r\n    event VoteCast(address indexed voter, string partyId, bytes32 voteHash, uint256 timestamp);\r\n    event PartyAdded(string id, string name);\r\n    event VotingReset(uint256 timestamp);\r\n    \r\n    // ============== Modifiers ==============\r\n    \r\n    modifier onlyAdmin() {\r\n        require(msg.sender == admin, \"Only admin can perform this action\");\r\n        _;\r\n    }\r\n    \r\n    modifier votingActive() {\r\n        require(isActive, \"Voting is not active\");\r\n        _;\r\n    }\r\n    \r\n    modifier hasNotVoted() {\r\n        require(!hasVoted[msg.sender], \"Already voted\");\r\n        _;\r\n    }\r\n    \r\n    // ============== Constructor ==============\r\n    \r\n    constructor() {\r\n        admin = msg.sender;\r\n        isActive = false;\r\n        totalVotes = 0;\r\n        \r\n        // Initialize default parties\r\n        _addParty(\"party1\", \"Progressive Alliance\", unicode\"🟦\", \"#3b82f6\");\r\n        _addParty(\"party2\", \"Democratic Unity\", unicode\"🟩\", \"#10b981\");\r\n        _addParty(\"party3\", \"People's Coalition\", unicode\"🟥\", \"#ef4444\");\r\n        _addParty(\"party4\", \"National Front\", unicode\"🟨\", \"#f59e0b\");\r\n    }\r\n    \r\n    // ============== Admin Functions ==============\r\n    \r\n    /**\r\n     * @dev Start voting session\r\n     */\r\n    function startVoting() external onlyAdmin {\r\n        require(!isActive, \"Voting already active\");\r\n        isActive = true;\r\n        sessionStartTime = block.timestamp;\r\n        emit VotingStarted(block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * @dev Stop voting session\r\n     */\r\n    function stopVoting() external onlyAdmin {\r\n        require(isActive, \"Voting not active\");\r\n        isActive = false;\r\n        sessionEndTime = block.timestamp;\r\n        emit VotingStopped(block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * @dev Reset voting session (clear all votes)\r\n     */\r\n    function resetVoting() external onlyAdmin {\r\n        // Clear all votes\r\n        for (uint256 i = 0; i < voters.length; i++) {\r\n            address voter = voters[i];\r\n            delete votes[voter];\r\n            delete hasVoted[voter];\r\n        }\r\n        \r\n        // Reset party vote counts\r\n        for (uint256 i = 0; i < partyIds.length; i++) {\r\n            parties[partyIds[i]].voteCount = 0;\r\n        }\r\n        \r\n        // Clear voters array\r\n        delete voters;\r\n        \r\n        // Reset counters\r\n        totalVotes = 0;\r\n        isActive = false;\r\n        sessionStartTime = 0;\r\n        sessionEndTime = 0;\r\n        \r\n        emit VotingReset(block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * @dev Add a new party\r\n     */\r\n    function addParty(\r\n        string memory _id,\r\n        string memory _name,\r\n        string memory _logo,\r\n        string memory _color\r\n    ) external onlyAdmin {\r\n        _addParty(_id, _name, _logo, _color);\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to add party\r\n     */\r\n    function _addParty(\r\n        string memory _id,\r\n        string memory _name,\r\n        string memory _logo,\r\n        string memory _color\r\n    ) internal {\r\n        require(!parties[_id].exists, \"Party already exists\");\r\n        \r\n        parties[_id] = Party({\r\n            id: _id,\r\n            name: _name,\r\n            logo: _logo,\r\n            color: _color,\r\n            voteCount: 0,\r\n            exists: true\r\n        });\r\n        \r\n        partyIds.push(_id);\r\n        emit PartyAdded(_id, _name);\r\n    }\r\n    \r\n    /**\r\n     * @dev Transfer admin rights\r\n     */\r\n    function transferAdmin(address newAdmin) external onlyAdmin {\r\n        require(newAdmin != address(0), \"Invalid address\");\r\n        admin = newAdmin;\r\n    }\r\n    \r\n    // ============== Voting Functions ==============\r\n    \r\n    /**\r\n     * @dev Cast a vote\r\n     * @param _partyId ID of the party to vote for\r\n     * @param _faceVerified Whether face verification was successful\r\n     * @param _userHash Hash representing the user (for privacy)\r\n     */\r\n    function castVote(\r\n        string memory _partyId,\r\n        bool _faceVerified,\r\n        bytes32 _userHash\r\n    ) external votingActive hasNotVoted {\r\n        require(parties[_partyId].exists, \"Invalid party\");\r\n        require(_faceVerified, \"Face verification required\");\r\n        \r\n        // Create vote hash for verification\r\n        bytes32 voteHash = keccak256(\r\n            abi.encodePacked(\r\n                msg.sender,\r\n                _partyId,\r\n                block.timestamp,\r\n                _faceVerified,\r\n                _userHash\r\n            )\r\n        );\r\n        \r\n        // Record vote\r\n        votes[msg.sender] = Vote({\r\n            voter: msg.sender,\r\n            partyId: _partyId,\r\n            timestamp: block.timestamp,\r\n            faceVerified: _faceVerified,\r\n            voteHash: voteHash,\r\n            exists: true\r\n        });\r\n        \r\n        // Mark as voted\r\n        hasVoted[msg.sender] = true;\r\n        voters.push(msg.sender);\r\n        \r\n        // Increment party vote count\r\n        parties[_partyId].voteCount++;\r\n        totalVotes++;\r\n        \r\n        emit VoteCast(msg.sender, _partyId, voteHash, block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * @dev Cast a vote on behalf of a user (admin only, for backend integration)\r\n     * @param _voter Address of the voter\r\n     * @param _partyId ID of the party to vote for\r\n     * @param _faceVerified Whether face verification was successful\r\n     * @param _userHash Hash representing the user (for privacy)\r\n     */\r\n    function castVoteFor(\r\n        address _voter,\r\n        string memory _partyId,\r\n        bool _faceVerified,\r\n        bytes32 _userHash\r\n    ) external onlyAdmin votingActive {\r\n        require(parties[_partyId].exists, \"Invalid party\");\r\n        require(_faceVerified, \"Face verification required\");\r\n        require(!hasVoted[_voter], \"Already voted\");\r\n        \r\n        // Create vote hash for verification\r\n        bytes32 voteHash = keccak256(\r\n            abi.encodePacked(\r\n                _voter,\r\n                _partyId,\r\n                block.timestamp,\r\n                _faceVerified,\r\n                _userHash\r\n            )\r\n        );\r\n        \r\n        // Record vote\r\n        votes[_voter] = Vote({\r\n            voter: _voter,\r\n            partyId: _partyId,\r\n            timestamp: block.timestamp,\r\n            faceVerified: _faceVerified,\r\n            voteHash: voteHash,\r\n            exists: true\r\n        });\r\n        \r\n        // Mark as voted\r\n        hasVoted[_voter] = true;\r\n        voters.push(_voter);\r\n        \r\n        // Increment party vote count\r\n        parties[_partyId].voteCount++;\r\n        totalVotes++;\r\n        \r\n        emit VoteCast(_voter, _partyId, voteHash, block.timestamp);\r\n    }\r\n    \r\n    // ============== View Functions ==============\r\n    \r\n    /**\r\n     * @dev Get voting status\r\n     */\r\n    function getVotingStatus() external view returns (\r\n        bool _isActive,\r\n        uint256 _totalVotes,\r\n        uint256 _startTime,\r\n        uint256 _endTime,\r\n        uint256 _partyCount\r\n    ) {\r\n        return (\r\n            isActive,\r\n            totalVotes,\r\n            sessionStartTime,\r\n            sessionEndTime,\r\n            partyIds.length\r\n        );\r\n    }\r\n    \r\n    /**\r\n     * @dev Get party details\r\n     */\r\n    function getParty(string memory _partyId) external view returns (\r\n        string memory name,\r\n        string memory logo,\r\n        string memory color,\r\n        uint256 voteCount\r\n    ) {\r\n        require(parties[_partyId].exists, \"Party does not exist\");\r\n        Party memory party = parties[_partyId];\r\n        return (party.name, party.logo, party.color, party.voteCount);\r\n    }\r\n    \r\n    /**\r\n     * @dev Get all party IDs\r\n     */\r\n    function getAllPartyIds() external view returns (string[] memory) {\r\n        return partyIds;\r\n    }\r\n    \r\n    /**\r\n     * @dev Get all party results\r\n     */\r\n    function getAllResults() external view returns (\r\n        string[] memory ids,\r\n        string[] memory names,\r\n        string[] memory logos,\r\n        uint256[] memory voteCounts\r\n    ) {\r\n        uint256 count = partyIds.length;\r\n        \r\n        ids = new string[](count);\r\n        names = new string[](count);\r\n        logos = new string[](count);\r\n        voteCounts = new uint256[](count);\r\n        \r\n        for (uint256 i = 0; i < count; i++) {\r\n            string memory partyId = partyIds[i];\r\n            Party memory party = parties[partyId];\r\n            \r\n            ids[i] = party.id;\r\n            names[i] = party.name;\r\n            logos[i] = party.logo;\r\n            voteCounts[i] = party.voteCount;\r\n        }\r\n        \r\n        return (ids, names, logos, voteCounts);\r\n    }\r\n    \r\n    /**\r\n     * @dev Check if address has voted\r\n     */\r\n    function hasUserVoted(address _voter) external view returns (bool) {\r\n        return hasVoted[_voter];\r\n    }\r\n    \r\n    /**\r\n     * @dev Get vote details (only voter or admin can see)\r\n     */\r\n    function getVote(address _voter) external view returns (\r\n        string memory partyId,\r\n        uint256 timestamp,\r\n        bool faceVerified,\r\n        bytes32 voteHash\r\n    ) {\r\n        require(\r\n            msg.sender == _voter || msg.sender == admin,\r\n            \"Unauthorized access\"\r\n        );\r\n        require(votes[_voter].exists, \"No vote found\");\r\n        \r\n        Vote memory vote = votes[_voter];\r\n        return (vote.partyId, vote.timestamp, vote.faceVerified, vote.voteHash);\r\n    }\r\n    \r\n    /**\r\n     * @dev Get total number of voters\r\n     */\r\n    function getVoterCount() external view returns (uint256) {\r\n        return voters.length;\r\n    }\r\n    \r\n    /**\r\n     * @dev Verify vote hash\r\n     */\r\n    function verifyVote(\r\n        address _voter,\r\n        string memory _partyId,\r\n        uint256 _timestamp,\r\n        bool _faceVerified,\r\n        bytes32 _userHash\r\n    ) external view returns (bool) {\r\n        require(votes[_voter].exists, \"No vote found\");\r\n        \r\n        bytes32 computedHash = keccak256(\r\n            abi.encodePacked(\r\n                _voter,\r\n                _partyId,\r\n                _timestamp,\r\n                _faceVerified,\r\n                _userHash\r\n            )\r\n        );\r\n        \r\n        return votes[_voter].voteHash == computedHash;\r\n    }\r\n}\r\n\r\n"
      }
    }
  }
}