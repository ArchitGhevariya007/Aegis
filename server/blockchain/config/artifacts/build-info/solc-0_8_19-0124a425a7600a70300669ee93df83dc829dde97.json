{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_19-0124a425a7600a70300669ee93df83dc829dde97",
  "solcVersion": "0.8.19",
  "solcLongVersion": "0.8.19+commit.7dd6d404",
  "userSourceNameMap": {
    "contracts/DocumentManager.sol": "project/contracts/DocumentManager.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "paris",
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/DocumentManager.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.19;\r\n\r\n/**\r\n * @title DocumentManager\r\n * @dev Smart contract for managing encrypted documents on blockchain\r\n * @author Aegis Digital Identity System\r\n */\r\ncontract DocumentManager {\r\n    \r\n    struct Document {\r\n        string documentHash;      // SHA256 hash of original document\r\n        string ipfsHash;         // IPFS hash where encrypted document is stored\r\n        string encryptionKey;    // Encrypted key for document decryption\r\n        address owner;           // Document owner\r\n        uint256 timestamp;       // When document was stored\r\n        bool exists;            // Whether document exists\r\n    }\r\n    \r\n    struct AccessPermission {\r\n        bool canAccess;         // Whether user can access document\r\n        uint256 grantedAt;      // When access was granted\r\n        address grantedBy;      // Who granted the access\r\n    }\r\n    \r\n    // State variables\r\n    mapping(uint256 => Document) private documents;\r\n    mapping(address => uint256[]) private userDocuments;\r\n    mapping(uint256 => mapping(address => AccessPermission)) private documentPermissions;\r\n    \r\n    uint256 private nextDocumentId = 1;\r\n    address public owner;\r\n    \r\n    // Events\r\n    event DocumentStored(\r\n        uint256 indexed documentId,\r\n        address indexed owner,\r\n        string documentHash,\r\n        string ipfsHash,\r\n        uint256 timestamp\r\n    );\r\n    \r\n    event DocumentAccessed(\r\n        uint256 indexed documentId,\r\n        address indexed accessor,\r\n        uint256 timestamp\r\n    );\r\n    \r\n    event PermissionGranted(\r\n        uint256 indexed documentId,\r\n        address indexed owner,\r\n        address indexed grantee,\r\n        uint256 timestamp\r\n    );\r\n    \r\n    event PermissionRevoked(\r\n        uint256 indexed documentId,\r\n        address indexed owner,\r\n        address indexed grantee,\r\n        uint256 timestamp\r\n    );\r\n    \r\n    // Modifiers\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Only contract owner can call this function\");\r\n        _;\r\n    }\r\n    \r\n    modifier onlyDocumentOwner(uint256 _documentId) {\r\n        require(documents[_documentId].exists, \"Document does not exist\");\r\n        require(documents[_documentId].owner == msg.sender, \"Only document owner can call this function\");\r\n        _;\r\n    }\r\n    \r\n    modifier documentExists(uint256 _documentId) {\r\n        require(documents[_documentId].exists, \"Document does not exist\");\r\n        _;\r\n    }\r\n    \r\n    modifier hasDocumentAccess(uint256 _documentId) {\r\n        require(documents[_documentId].exists, \"Document does not exist\");\r\n        require(\r\n            documents[_documentId].owner == msg.sender || \r\n            documentPermissions[_documentId][msg.sender].canAccess,\r\n            \"Access denied\"\r\n        );\r\n        _;\r\n    }\r\n    \r\n    constructor() {\r\n        owner = msg.sender;\r\n    }\r\n    \r\n    /**\r\n     * @dev Store a new document on the blockchain\r\n     * @param _documentHash SHA256 hash of the original document\r\n     * @param _ipfsHash IPFS hash where encrypted document is stored\r\n     * @param _encryptionKey Encryption key for document decryption\r\n     * @param _documentOwner Owner of the document\r\n     * @return documentId The ID of the stored document\r\n     */\r\n    function storeDocument(\r\n        string memory _documentHash,\r\n        string memory _ipfsHash,\r\n        string memory _encryptionKey,\r\n        address _documentOwner\r\n    ) public returns (uint256) {\r\n        require(bytes(_documentHash).length > 0, \"Document hash cannot be empty\");\r\n        require(bytes(_ipfsHash).length > 0, \"IPFS hash cannot be empty\");\r\n        require(bytes(_encryptionKey).length > 0, \"Encryption key cannot be empty\");\r\n        require(_documentOwner != address(0), \"Invalid document owner address\");\r\n        \r\n        uint256 documentId = nextDocumentId;\r\n        nextDocumentId++;\r\n        \r\n        documents[documentId] = Document({\r\n            documentHash: _documentHash,\r\n            ipfsHash: _ipfsHash,\r\n            encryptionKey: _encryptionKey,\r\n            owner: _documentOwner,\r\n            timestamp: block.timestamp,\r\n            exists: true\r\n        });\r\n        \r\n        userDocuments[_documentOwner].push(documentId);\r\n        \r\n        emit DocumentStored(\r\n            documentId,\r\n            _documentOwner,\r\n            _documentHash,\r\n            _ipfsHash,\r\n            block.timestamp\r\n        );\r\n        \r\n        return documentId;\r\n    }\r\n    \r\n    /**\r\n     * @dev Get document information\r\n     * @param _documentId ID of the document\r\n     * @return documentHash SHA256 hash of the document\r\n     * @return ipfsHash IPFS hash of the encrypted document\r\n     * @return encryptionKey Encryption key for decryption\r\n     * @return documentOwner Owner of the document\r\n     * @return timestamp When the document was stored\r\n     */\r\n    function getDocument(uint256 _documentId) \r\n        public \r\n        view \r\n        hasDocumentAccess(_documentId) \r\n        returns (\r\n            string memory documentHash,\r\n            string memory ipfsHash,\r\n            string memory encryptionKey,\r\n            address documentOwner,\r\n            uint256 timestamp\r\n        ) \r\n    {\r\n        Document memory doc = documents[_documentId];\r\n        return (\r\n            doc.documentHash,\r\n            doc.ipfsHash,\r\n            doc.encryptionKey,\r\n            doc.owner,\r\n            doc.timestamp\r\n        );\r\n    }\r\n    \r\n    /**\r\n     * @dev Get all document IDs owned by a user\r\n     * @param _owner Address of the document owner\r\n     * @return Array of document IDs\r\n     */\r\n    function getUserDocuments(address _owner) public view returns (uint256[] memory) {\r\n        return userDocuments[_owner];\r\n    }\r\n    \r\n    /**\r\n     * @dev Grant access permission to a user for a specific document\r\n     * @param _documentId ID of the document\r\n     * @param _user Address of the user to grant access\r\n     * @param _canAccess Whether to grant or revoke access\r\n     */\r\n    function setDocumentPermission(\r\n        uint256 _documentId,\r\n        address _user,\r\n        bool _canAccess\r\n    ) public onlyDocumentOwner(_documentId) {\r\n        require(_user != address(0), \"Invalid user address\");\r\n        require(_user != documents[_documentId].owner, \"Cannot set permission for document owner\");\r\n        \r\n        documentPermissions[_documentId][_user] = AccessPermission({\r\n            canAccess: _canAccess,\r\n            grantedAt: block.timestamp,\r\n            grantedBy: msg.sender\r\n        });\r\n        \r\n        if (_canAccess) {\r\n            emit PermissionGranted(_documentId, msg.sender, _user, block.timestamp);\r\n        } else {\r\n            emit PermissionRevoked(_documentId, msg.sender, _user, block.timestamp);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev Check if a user has access to a document\r\n     * @param _documentId ID of the document\r\n     * @param _user Address of the user\r\n     * @return Whether the user has access\r\n     */\r\n    function hasAccess(uint256 _documentId, address _user) \r\n        public \r\n        view \r\n        documentExists(_documentId) \r\n        returns (bool) \r\n    {\r\n        return documents[_documentId].owner == _user || \r\n               documentPermissions[_documentId][_user].canAccess;\r\n    }\r\n    \r\n    /**\r\n     * @dev Get access permission details\r\n     * @param _documentId ID of the document\r\n     * @param _user Address of the user\r\n     * @return canAccess Whether user can access\r\n     * @return grantedAt When access was granted\r\n     * @return grantedBy Who granted the access\r\n     */\r\n    function getAccessPermission(uint256 _documentId, address _user) \r\n        public \r\n        view \r\n        documentExists(_documentId) \r\n        returns (bool canAccess, uint256 grantedAt, address grantedBy) \r\n    {\r\n        AccessPermission memory permission = documentPermissions[_documentId][_user];\r\n        return (permission.canAccess, permission.grantedAt, permission.grantedBy);\r\n    }\r\n    \r\n    /**\r\n     * @dev Record document access for audit trail\r\n     * @param _documentId ID of the document being accessed\r\n     */\r\n    function recordAccess(uint256 _documentId) public hasDocumentAccess(_documentId) {\r\n        emit DocumentAccessed(_documentId, msg.sender, block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * @dev Verify document integrity by comparing hashes\r\n     * @param _documentId ID of the document\r\n     * @param _providedHash Hash to verify against\r\n     * @return Whether the hashes match\r\n     */\r\n    function verifyDocumentIntegrity(uint256 _documentId, string memory _providedHash) \r\n        public \r\n        view \r\n        hasDocumentAccess(_documentId) \r\n        returns (bool) \r\n    {\r\n        return keccak256(abi.encodePacked(documents[_documentId].documentHash)) == \r\n               keccak256(abi.encodePacked(_providedHash));\r\n    }\r\n    \r\n    /**\r\n     * @dev Get total number of documents stored\r\n     * @return Total document count\r\n     */\r\n    function getTotalDocuments() public view returns (uint256) {\r\n        return nextDocumentId - 1;\r\n    }\r\n    \r\n    /**\r\n     * @dev Check if a document exists\r\n     * @param _documentId ID of the document\r\n     * @return Whether the document exists\r\n     */\r\n    function isDocumentExists(uint256 _documentId) public view returns (bool) {\r\n        return documents[_documentId].exists;\r\n    }\r\n    \r\n    /**\r\n     * @dev Get document owner\r\n     * @param _documentId ID of the document\r\n     * @return Address of the document owner\r\n     */\r\n    function getDocumentOwner(uint256 _documentId) \r\n        public \r\n        view \r\n        documentExists(_documentId) \r\n        returns (address) \r\n    {\r\n        return documents[_documentId].owner;\r\n    }\r\n    \r\n    /**\r\n     * @dev Emergency function to update contract owner (only current owner)\r\n     * @param _newOwner Address of the new contract owner\r\n     */\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        require(_newOwner != address(0), \"Invalid new owner address\");\r\n        owner = _newOwner;\r\n    }\r\n    \r\n    /**\r\n     * @dev Get contract version\r\n     * @return Contract version string\r\n     */\r\n    function getVersion() public pure returns (string memory) {\r\n        return \"1.0.0\";\r\n    }\r\n}\r\n"
      }
    }
  }
}